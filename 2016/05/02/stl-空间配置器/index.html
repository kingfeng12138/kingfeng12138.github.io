<!DOCTYPE html>
<html >
<head>
  <meta charset="utf-8">
  
  <title>stl_空间配置器 | LOVE LINUX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="空间配置器空间配置器: 用来分配内存。它并不会给我们直接使用，而是在容器之后默默工作。
在c++中，一般使用new在c++中，一般使用new来来分配内存，同时并调用构造函数来完成值得初始化，但在stl中，这两步是分开的首先有空间配置器来分配内存，然后调用construct函数来完成在指定内存完成值得初始化。构造可以调用place new 来在指定的内存空间来声明对象，和初始化值。但是毕竟类才需要调">
<meta property="og:type" content="article">
<meta property="og:title" content="stl_空间配置器">
<meta property="og:url" content="http://0x00000000.cn/2016/05/02/stl-空间配置器/index.html">
<meta property="og:site_name" content="LOVE LINUX">
<meta property="og:description" content="空间配置器空间配置器: 用来分配内存。它并不会给我们直接使用，而是在容器之后默默工作。
在c++中，一般使用new在c++中，一般使用new来来分配内存，同时并调用构造函数来完成值得初始化，但在stl中，这两步是分开的首先有空间配置器来分配内存，然后调用construct函数来完成在指定内存完成值得初始化。构造可以调用place new 来在指定的内存空间来声明对象，和初始化值。但是毕竟类才需要调">
<meta property="og:updated_time" content="2016-08-15T09:08:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="stl_空间配置器">
<meta name="twitter:description" content="空间配置器空间配置器: 用来分配内存。它并不会给我们直接使用，而是在容器之后默默工作。
在c++中，一般使用new在c++中，一般使用new来来分配内存，同时并调用构造函数来完成值得初始化，但在stl中，这两步是分开的首先有空间配置器来分配内存，然后调用construct函数来完成在指定内存完成值得初始化。构造可以调用place new 来在指定的内存空间来声明对象，和初始化值。但是毕竟类才需要调">
  
    <link rel="alternative" href="/atom.xml" title="LOVE LINUX" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Jin Feng</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effective-c/">Effective c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO复用/">IO复用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC/">IPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/avl树/">avl树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux基础/">linux基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/malloc/">malloc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ncurses/">ncurses</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python爬虫/">python爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stl/">stl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unix-c/">unix_c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数原型/">函数原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多态/">多态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户态内核态/">用户态内核态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题/">面试题</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://my.oschina.net/cnyinlinux">cnyinlinux</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zmy123.cn">IT-追梦园</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://rubbly.cn">Rubbly</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://xknow.net">认知</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://leejiahao.com">leejiahao</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.Riyadhlinux.com/wordpress">Riyadh</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.learnandroid.cn">xavier</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/github_33736971">Linux_minbao</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于c++</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Jin Feng</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Jin Feng</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><article id="post-stl-空间配置器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/stl-空间配置器/" class="article-date">
      <time datetime="2016-05-02T04:09:10.000Z" itemprop="datePublished">2016-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      stl_空间配置器
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/">stl</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h2><p>空间配置器: 用来分配内存。它并不会给我们直接使用，而是在容器之后默默工作。</p>
<p>在c++中，一般使用new<br>在c++中，一般使用new来来分配内存，同时并调用构造函数来完成值得初始化，但在stl中，这两步是分开的<br>首先有空间配置器来分配内存，然后调用construct函数来完成在指定内存完成值得初始化。<br>构造可以调用place new 来在指定的内存空间来声明对象，和初始化值。但是毕竟类才需要调用构造，<br>有的对象并不需要使用构造函数。使用简单的内存拷贝就能达到目的。<br><a id="more"></a><br>sgi中使用的默认的空间配置器是alloc。 alloc有两种不同的方式来分配内存。当所申请的空间大于128B的时候<br>直接调用c语言中的malloc来来申请内存, free来释放内存，而小于128B的空间，就在内存池中分配。</p>
<h2 id="空间配置器标准接口"><a href="#空间配置器标准接口" class="headerlink" title="空间配置器标准接口"></a>空间配置器标准接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line">allocator::rebind</span><br><span class="line">allocator::allocator()   <span class="comment">//默认构造</span></span><br><span class="line">allocator::allocator(<span class="keyword">const</span> allocator&amp;)   <span class="comment">//拷贝构造</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;allocator::allocator::allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span><br><span class="line">allocator::~allocator()   <span class="comment">//析构</span></span><br><span class="line">pointer allocator::address(reference x) <span class="keyword">const</span>  <span class="comment">//返回某个对象的地址</span></span><br><span class="line">pointer allocator::allocate(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>) <span class="comment">//配置空间，足以存储n个T对象</span></span><br><span class="line"><span class="keyword">void</span> allocator::deallocate(pointer p, size_type n)  <span class="comment">//归还先前配置的空间</span></span><br><span class="line">size_type allocator::max_size() <span class="keyword">const</span>     <span class="comment">//返回可以配置的最大值</span></span><br><span class="line"><span class="keyword">void</span> allocator::construct(pointer p, <span class="keyword">const</span> T&amp;x)  <span class="comment">//相当于new((void *) p) T(x)</span></span><br><span class="line"><span class="keyword">void</span> allocator::destroy(pointer p)       <span class="comment">//相当于p-&gt;~T()</span></span><br></pre></td></tr></table></figure>
<h2 id="sgi中的空间配置器"><a href="#sgi中的空间配置器" class="headerlink" title="sgi中的空间配置器"></a>sgi中的空间配置器</h2><p>sgi中使用alloc作为默认的空间配置器，但是该配置器并不真正符合标准接口。但是sgi中是默认使用alloc的<br>在sgi中:<br>stl_construct.h     定义了construct()和destroy()<br>stl_alloc.h         定义了一二级空间配置器，名为alloc<br>stl_uninitialized.h 定义了一些全局函数用来填充或者复制内存数据。<br>                      stl_initialized_copy<br>                      stl_initialized_fill()<br>                      stl_initialized_fill_n()</p>
<h3 id="construct-和destroy"><a href="#construct-和destroy" class="headerlink" title="construct()和destroy()"></a>construct()和destroy()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="keyword">const</span> T2&amp; value)</span> </span>&#123;</span><br><span class="line">    new (p) T1(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种版本，接受一个对象指针，直接调用对象的析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *pointer)</span> </span>&#123;</span><br><span class="line">    pointer-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个版本, 接受两个迭代器，通过萃取，来判定迭代器指向的对象是否需要调用析构函数</span></span><br><span class="line"><span class="comment">//所以分别是__true_type 和__false_type 两个版本。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">    __destroy(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy(ForwardIterator first, ForwardIterator last, T *) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trival_destructor trivial_destructor;</span><br><span class="line">    __destroy_aux(first, last, trivial_destructor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __false_type) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">        destroy(&amp;*first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一级空间配置器"><a href="#一级空间配置器" class="headerlink" title="一级空间配置器"></a>一级空间配置器</h3><p>一级空间配置器<br><code>__malloc_alloc_template</code><br>一级空间配置器直接使用了c中的malloc() free() realloc()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int inst&gt;</span><br><span class="line">class __malloc_alloc_template &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">static void * allocate(size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    void *result = malloc(n);</span><br><span class="line">    if (0 == result) result = oom_malloc(n);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void deallocate(void *p, size_t)</span><br><span class="line">&#123;</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br><span class="line">static void *reallocate(void *p, size_t , size_t new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    void *result = realloc(p, new_sz);</span><br><span class="line">    if (0 == result) result = oom_realoc(p, new_sz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void (* set_malloc_handler(void (*f)()))()</span><br><span class="line">&#123;</span><br><span class="line">    void (* old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler =f;</span><br><span class="line">    return (old)</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">static void *oom_malloc(size_t);</span><br><span class="line"></span><br><span class="line">static void *oom_realloc(void *, size_t);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二级空间配置器"><a href="#二级空间配置器" class="headerlink" title="二级空间配置器"></a>二级空间配置器</h3><p><code>__default_alloc_template</code><br>二级空间配置器采用的是内存池的方式。<br>先自动将申请的空间拓展到8的倍数。<br>二级空间配置器8， 16， 24， 32， 40， 48， 56， 64， 72， 80， 88， 96， 104， 112， 120， 128</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> __default_alloc_template &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(size_t bytes)</span> </span>&#123;        <span class="comment">//将实际申请的空间上调至8的倍数</span></span><br><span class="line">        return (((bytes) + __ALIGN - <span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">__PRIVATE:</span><br><span class="line">    <span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj * free_list_link;     <span class="comment">//采用共用体，当空闲的时候使用obj</span></span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];            <span class="comment">//使用的时候使用client_data</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> obj * __VOLATILE free_list[_NFREELISTS];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(size_t bytes)</span> </span>&#123;    <span class="comment">//根据内存大小来判定所属于哪一条空闲链</span></span><br><span class="line">        return (((bytes) + _ALIGN - <span class="number">1</span>) / __ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(size_t n)</span></span>;  <span class="comment">//当某一条空闲链为空，就再申请一片</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(size_ t size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *start_free;    <span class="comment">//内存池起始位置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *end_free;      <span class="comment">//内存池结束位置。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(size_t n)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, size_t n)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, size_t old_sz, size_t new _sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>allocate</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(size_t n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        return (malloc_alloc::allocate(n));  <span class="comment">//当申请大小大于128就调用一级空间配置器</span></span><br><span class="line">    &#125;</span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//说明free_list 为空，需要重新填充free_list</span></span><br><span class="line">        <span class="keyword">void</span> *r = refill(ROUND_UP(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//挂链，调整free list</span></span><br><span class="line">    *my_free_list = result-&gt;free_list_link;</span><br><span class="line">    return (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deallocate</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">deallocate</span><span class="params">(size_t n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    obj *q = (obj *)p;</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    <span class="comment">//如果释放的空间大于128则调用一级空间配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span> ) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::deallocate(p, n);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找对应的free list</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    q-&gt;free_list_link = *my_free_list; <span class="comment">//头插,挂链</span></span><br><span class="line">    *my_free_list = q;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refill函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> * __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">     <span class="comment">//chunk_alloc从内存池中申请内存。</span></span><br><span class="line">     <span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);</span><br><span class="line">     obj *<span class="keyword">volatile</span> *my_free_list;</span><br><span class="line">     obj *result;</span><br><span class="line">     obj *current_obj, *next_obj;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果只获得一个区块，这个却快就分配给调用者用，free_list无新节点</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="number">1</span> == nobjs) return (chunk);</span><br><span class="line">     <span class="comment">//否则调整free_list,插入新的节点</span></span><br><span class="line">     my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line"></span><br><span class="line">     result = (obj *)chunk; <span class="comment">//这一块准备返回给客户端</span></span><br><span class="line">     *my_free_list = next_obj = (obj *)(chunk + n);</span><br><span class="line">     <span class="comment">//将剩下的所有节点挂链</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">         current_obj = next_obj;</span><br><span class="line">         next_obj = (obj *)((char *)next_obj　+ n);</span><br><span class="line">         <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">             current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内存池管理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line">chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        <span class="comment">//内存池中剩余的内存能够分配nobjs个节点</span></span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        return (result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">        <span class="comment">//内存池中的剩余空间不能分配所有，但是能够分配一个以上</span></span><br><span class="line">        nobjs = bytes_left / size;</span><br><span class="line">        total_bytes = size * nobjs;</span><br><span class="line">        result = start_size;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        return (result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//内存池中的内存不够分配一个</span></span><br><span class="line">        <span class="comment">//计算接下来要分配的空间大小 需求的两倍加上</span></span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//把剩下的零头分配给合适的free_list</span></span><br><span class="line">           obj * <span class="keyword">volatile</span> *my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">           <span class="comment">//调整free_list 将剩余的空间插入到空闲的链表</span></span><br><span class="line">           ((obj *)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">           *my_free_list = (obj *)start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        start_free = (char *)<span class="built_in">malloc</span>(bytes_to_get)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h3><h4 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h4><p>将first和last之间的元素拷贝到result开始的空间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line"><span class="function">ForwardIterator</span><br><span class="line"><span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last,</span><br><span class="line">                   ForwardIterator result)</span></span><br><span class="line"> </span>&#123;</span><br><span class="line">     <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::is_POD_type is_POD;</span><br><span class="line">     return __uninitialized_copy_aux(first, last, result, is_POD());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last,</span><br><span class="line">                       ForwardIterator result,</span><br><span class="line">                       __true_type) &#123;</span><br><span class="line">    copy(first, last, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last,</span><br><span class="line">                       ForwardIterator result,</span><br><span class="line">                       __false_type) &#123;</span><br><span class="line">   <span class="keyword">for</span> (; first != last; ++first, ++cur)</span><br><span class="line">       construct(&amp;*cur, *first);</span><br><span class="line">   return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当迭代器所指向的对象为true_type 就直接调用函数来进行拷贝，否则需要对每个元素进行构造</p>
<h4 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h4><p>将first到last之间的元素以x来初始化<br>通过萃取出迭代器所指向元素的值得类型来作出不同的操作<br>true_type直接调用函数fill，false_type需要分别调用每个的构造函数<br>同时对char和wchar_t 类型分别生成特别的版本<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                        <span class="keyword">const</span> T&amp; x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    __unitialalized_fill(first, last, x, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T, <span class="keyword">class</span> T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                              <span class="keyword">const</span> T&amp; x, T1*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::<span class="function">is_POD_type <span class="title">is_POD</span><span class="params">()</span></span>;</span><br><span class="line">    __uninitialized_fill_aux(first, last, x, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                         <span class="keyword">const</span> T&amp;x, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">    fill(first, last, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                         <span class="keyword">const</span> T&amp; x, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; cur != last; ++cur)</span><br><span class="line">        construct(&amp;*cur, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//针对char 和wchar_t的特化版本，直接调用memmove函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *first, <span class="keyword">const</span> <span class="keyword">char</span>* last,</span><br><span class="line">                                <span class="keyword">char</span> * result)</span> </span>&#123;</span><br><span class="line">    memmove(result, first, last - first);</span><br><span class="line">    return result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> wchar_t* <span class="title">uninitialized_copy</span><span class="params">(<span class="keyword">const</span> wchar_t *first, <span class="keyword">const</span> wchar_t *last,</span><br><span class="line">                                   wchar_t* result)</span> </span>&#123;</span><br><span class="line">    memmove(result, first, <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) * (last - first));</span><br><span class="line">    return result + (last - first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h4><p>该函数的作用:<br>将迭代器first之后n个单元初始化为x。<br>通过萃取出迭代器所指向元素的值得类型来作出不同的操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function">ForwardIterator</span><br><span class="line"><span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n, <span class="keyword">const</span> T &amp;x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return __uninitialized_fill_n(first, n, x, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __unitiallized_fill_n(ForwardIterator first, Size n,</span><br><span class="line">                                             <span class="keyword">const</span> T&amp; x, T1 *)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">    return __uninitialized_fill_n_aux(first, n, x, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator</span><br><span class="line">__unitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                        <span class="keyword">const</span> T&amp; x, __true_type) &#123;</span><br><span class="line">    return fill_n(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator</span><br><span class="line">__unitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                         <span class="keyword">const</span> T&amp; x, __false_type) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</span><br><span class="line">        construct(&amp;*cur, x);</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2016/05/02/stl-空间配置器/">stl_空间配置器</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage">Jin Feng</a></p>
        <p><span>Created:</span>2016-05-02, 12:09:10</p>
        <p><span>Updated:</span>2016-08-15, 17:08:32</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2016/05/02/stl-空间配置器/" title="stl_空间配置器">http://0x00000000.cn/2016/05/02/stl-空间配置器/</a>
            <span class="copy-path" data-clipboard-text="From http://0x00000000.cn/2016/05/02/stl-空间配置器/　　By Jin Feng" title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/05/05/stl-avl树/">
                    stl--avl树
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/04/06/算法-大整数算法/">
                    算法--大整数算法
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#空间配置器"><span class="toc-number">1.</span> <span class="toc-text">空间配置器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空间配置器标准接口"><span class="toc-number">2.</span> <span class="toc-text">空间配置器标准接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sgi中的空间配置器"><span class="toc-number">3.</span> <span class="toc-text">sgi中的空间配置器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#construct-和destroy"><span class="toc-number">3.1.</span> <span class="toc-text">construct()和destroy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一级空间配置器"><span class="toc-number">3.2.</span> <span class="toc-text">一级空间配置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二级空间配置器"><span class="toc-number">3.3.</span> <span class="toc-text">二级空间配置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存基本处理工具"><span class="toc-number">3.4.</span> <span class="toc-text">内存基本处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uninitialized-copy"><span class="toc-number">3.4.1.</span> <span class="toc-text">uninitialized_copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uninitialized-fill"><span class="toc-number">3.4.2.</span> <span class="toc-text">uninitialized_fill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uninitialized-fill-n"><span class="toc-number">3.4.3.</span> <span class="toc-text">uninitialized_fill_n</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">
<script>
    var valueHide = "Hide";
    var valueShow = "Show";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"stl_空间配置器　| LOVE LINUX　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/05/02/stl-空间配置器/" data-title="stl_空间配置器" data-url="http://0x00000000.cn/2016/05/02/stl-空间配置器/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"kingfeng12138"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/05/05/stl-avl树/" title="Pre: stl--avl树">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/04/06/算法-大整数算法/" title="Next: 算法--大整数算法">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/06/Efective-c-整理一/">Effective c++ 整理一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/04/DNS解析过程/">DNS解析过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/03/unix-c-用户态和内核态的区别/">unix-c-用户态和内核态的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/13/python爬虫-爬取一波美女图/">python爬虫-爬取一波美女图</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/04/unix-c-IO复用/">unix_c-IO复用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/cpp多态的实现/">c++多态的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/01/ncurse库的使用/">ncurses库的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/23/stl-vector的实现/">stl--vector的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/07/http协议/">http协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/07/tcp-11种状态/">tcp--11种状态</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/05/stl-avl树/">stl--avl树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/02/stl-空间配置器/">stl_空间配置器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/06/算法-大整数算法/">算法--大整数算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/06/shell-字符处理/">shell-字符处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/面试题整理2/">面试题整理2</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/09/数据结构-红黑树/">数据结构--红黑树</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/算法-将两个栈封装成队列/">算法--将两个栈封装成队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/算法-kmp字符串匹配算法/">算法--kmp字符串匹配算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/04/面试题整理1/">面试题整理1</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/17/unix-c-IPC使用步骤/">unix_c--IPC使用步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/09/mysql-c语言编程/">mysql--c语言编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/07/mysql的安装/">mysql的安装(服务端，客户端，mysql库)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/17/unix-c-线程学习/">unix_c--线程学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/31/unix-c-IPC进程通信学习/">unix-c-IPC进程通信学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/25/unix-c-信号学习/">unix_c--信号学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/20/unix-c-IO学习/">unix_c--IO学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/20/unix-c-开机流程/">unix-c--开机流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/20/picture-test/">picture_test</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/07/unix-c-makefile写法/">unix_c--makefile写法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/07/shell-expect用法/">shell--expect用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/06/shell-awk和sed用法/">shell--awk和sed用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/06/shell-find用法/">shell--find用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/06/linux-修改PS1的值/">linux--修改PS1的值</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/04/unix-c-静态链接库和动态链接库/">unix_c--静态链接库和动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/26/linux-修改redhat7的截图配置/">linux--修改redhat7的截图配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/23/算法-排序算法整理/">算法--排序算法整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/22/数据结构-将通用双端链表封装成队列/">数据结构--将通用双端链表封装成队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/20/数据结构-将通用双端链表封装成栈/">数据结构--将通用双端链表封装成栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/20/数据结构-带控制信息的双向链表/">数据结构--带控制信息的双向链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/01/数据结构-单向链表的操作-带表头/">数据结构--单向链表的操作(带表头)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/11/c语言-一个很搓的malloc的实现/">c语言--一个很搓的malloc的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/04/c语言-strtok函数的实现/">c语言--strtok函数的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/04/c语言-位操作实现ftoi/">c语言--位操作实现ftoi</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/03/c语言-素数的查找/">c语言--素数的查找</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/03/c语言-两个整数的交换函数/">c语言--两个整数的交换函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/03/c语言-strcpy函数实现/">c语言--strcpy函数实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/27/linux学习-磁盘分区和lvm的使用/">linux学习--磁盘分区和lvm的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/27/linux学习-yum使用yum源配置/">linux学习--yum使用yum源配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/27/linux学习-文件打包压缩/">linux学习--文件打包压缩</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/26/linux学习-网络设置/">linux学习--网络设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/24/学长推荐的书/">学长推荐的书</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/24/linux学习-openssh的使用/">linux学习--openssh的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/24/linux学习-进程管理/">linux学习--进程管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/24/linux学习-文件存储管理/">linux学习--文件存储管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/22/linux学习-权限和特殊权限/">linux学习--权限和特殊权限</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/22/linux学习-用户和组的管理/">linux学习--用户和组的管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/22/linux学习-文本编辑以vim/">linux学习--文本编辑以vim</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/22/linux学习-管道和重定向/">linux学习--管道和重定向</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/21/linux学习-系统相关指令/">linux学习--系统相关指令</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/21/linux学习-文件基本操作/">linux学习--文件基本操作</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 Jin Feng
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >Site Visitors: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">Page Hits: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>




<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>